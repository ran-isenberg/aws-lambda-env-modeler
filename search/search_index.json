{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#aws-lambda-environment-variables-parser-cookbook","title":"AWS Lambda Environment Variables Parser Cookbook","text":"<p>AWS-Lambda-Env-Modeler is a Python library designed to simplify the process of managing and validating environment variables in your AWS Lambda functions.</p> <p>It leverages the power of Pydantic models to define the expected structure and types of the environment variables.</p> <p>This library is especially handy for serverless applications where managing configuration via environment variables is a common practice.</p>"},{"location":"#the-problem","title":"The Problem","text":"<p>Environment variables are often viewed as an essential utility. They serve as static AWS Lambda function configuration.</p> <p>Their values are set during the Lambda deployment, and the only way to change them is to redeploy the Lambda function with updated values.</p> <p>However, many engineers use them unsafely despite being such an integral and fundamental part of any AWS Lambda function deployment.</p> <p>This usage may cause nasty bugs or even crashes in production.</p> <p>This library allows you to correctly parse, validate, and use your environment variables in your Python AWS Lambda code.</p> <p>Read more about it here</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Validates the environment variables against a Pydantic model: define both semantic and syntactic validation.</li> <li>Serializes the string environment variables into complex classes and types.</li> <li>Provides means to access the environment variables safely with a global getter function in every part of the function.</li> <li>Provides a decorator to initialize the environment variables before executing a function.</li> <li>Caches the parsed model for performance improvement for multiple 'get' calls.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install it using pip:</p> <pre><code>pip install aws-lambda-env-modeler\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#schema-definition","title":"Schema Definition","text":"<p>First, define a Pydantic model for your environment variables:</p> schema.py<pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, HttpUrl\n\nfrom aws_lambda_env_modeler.types import Annotated\n\n\nclass MyEnvVariables(BaseModel):\n    REST_API: HttpUrl\n    ROLE_ARN: Annotated[str, Field(min_length=20, max_length=2048)]\n    POWERTOOLS_SERVICE_NAME: Annotated[str, Field(min_length=1)]\n    LOG_LEVEL: Literal['DEBUG', 'INFO', 'ERROR', 'CRITICAL', 'WARNING', 'EXCEPTION']\n</code></pre> <p>Notice how you can use advanced types and value assertions and not just plain strings.</p>"},{"location":"#decorator","title":"Decorator","text":"<p>Before executing a function, you must use the <code>@init_environment_variables</code> decorator to validate and initialize the environment variables automatically.</p> <p>The decorator guarantees that the function will run with the correct variable configuration.</p> <p>Then, you can fetch the environment variables using the global getter function, 'get_environment_variables,' and use them just like a data class. At this point, they are parsed and validated.</p> my_handler.py<pre><code>import json\nfrom http import HTTPStatus\nfrom typing import Any, Dict, Literal\n\nfrom pydantic import BaseModel, Field, HttpUrl\n\nfrom aws_lambda_env_modeler import get_environment_variables, init_environment_variables\nfrom aws_lambda_env_modeler.types import Annotated\n\n\nclass MyHandlerEnvVars(BaseModel):\n    REST_API: HttpUrl\n    ROLE_ARN: Annotated[str, Field(min_length=20, max_length=2048)]\n    POWERTOOLS_SERVICE_NAME: Annotated[str, Field(min_length=1)]\n    LOG_LEVEL: Literal['DEBUG', 'INFO', 'ERROR', 'CRITICAL', 'WARNING', 'EXCEPTION']\n\n\n@init_environment_variables(model=MyHandlerEnvVars)\ndef my_handler(event: Dict[str, Any], context) -&gt; Dict[str, Any]:\n    env_vars = get_environment_variables(model=MyHandlerEnvVars)  # noqa: F841\n    # can access directly env_vars.REST_API, env_vars.ROLE_ARN as dataclass\n    return {\n        'statusCode': HTTPStatus.OK,\n        'headers': {'Content-Type': 'application/json'},\n        'body': json.dumps({'message': 'success'}),\n    }\n</code></pre>"},{"location":"#disabling-cache-for-testing","title":"Disabling Cache for Testing","text":"<p>By default, the modeler uses cache - the parsed model is cached for performance improvement for multiple 'get' calls.</p> <p>In some cases, such as during testing, you may want to turn off the cache. You can do this by setting the <code>LAMBDA_ENV_MODELER_DISABLE_CACHE</code> environment variable to 'True.'</p> <p>This is especially useful in tests where you want to run multiple tests concurrently, each with a different set of environment variables.</p> <p>Here's an example of how you can use this in a pytest test:</p> pytest.py<pre><code>import json\nfrom http import HTTPStatus\nfrom typing import Any, Dict, Literal\nfrom unittest.mock import patch\n\nfrom pydantic import BaseModel\n\nfrom aws_lambda_env_modeler import LAMBDA_ENV_MODELER_DISABLE_CACHE, get_environment_variables, init_environment_variables\n\n\nclass MyHandlerEnvVars(BaseModel):\n    LOG_LEVEL: Literal['DEBUG', 'INFO', 'ERROR', 'CRITICAL', 'WARNING', 'EXCEPTION']\n\n\n@init_environment_variables(model=MyHandlerEnvVars)\ndef my_handler(event: Dict[str, Any], context) -&gt; Dict[str, Any]:\n    env_vars = get_environment_variables(model=MyHandlerEnvVars)  # noqa: F841\n    # can access directly env_vars.LOG_LEVEL as dataclass\n    return {\n        'statusCode': HTTPStatus.OK,\n        'headers': {'Content-Type': 'application/json'},\n        'body': json.dumps({'message': 'success'}),\n    }\n\n\n@patch.dict('os.environ', {LAMBDA_ENV_MODELER_DISABLE_CACHE: 'true', 'LOG_LEVEL': 'DEBUG'})\ndef test_my_handler():\n    response = my_handler({}, None)\n    assert response['statusCode'] == HTTPStatus.OK\n    assert response['headers'] == {'Content-Type': 'application/json'}\n    assert json.loads(response['body']) == {'message': 'success'}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This library is licensed under the MIT License. See the LICENSE file.</p>"}]}